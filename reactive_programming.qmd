---
title: "Demystifying Reactive Programming"
engine: knitr
format: html
---

## Avoiding Tying Big Changes to Controls

```{r}
#| context: setup

library(shiny)
library(bslib)
```

## `reactive()` - the most general case

```{r}
sliderInput("latSlider", "Choose a Latitude", min = 30, max=40, value=35)
sliderInput("longSlider", "Choose a Longitude", min= 30, max=40, value=35)
```

If either `latSlider`, or `longSlider` are changed, then recompute.

```{mermaid}
flowchart LR
    D["coords()"] --> E
    B[latSlider] --> D
    C[longSlider] --> D
    E[leafletPlot]
```

## `isolate()`: don't use an input as a dependency

Use in a reactive to disconnect controls from recomputation. If `longSlider` changes, then don't recompute. If `latSlider` changes, recompute

```{mermaid}
flowchart LR
    D["coords()"] --> E
    B["latSlider"] --> D
    C["isolate(longSlider)"] --X --> D
    E[leafletPlot]
```

## `reactiveValues`

Use like a list to store values for multiple reactive expressions. Recompute when any reactive expression changes:


```{mermaid}
flowchart LR
  D["coords()"] --> E
  E[leafletPlot]
  subgraph reactiveValues
    B[latSlider] --> D
    C[longSlider] --> D
  end
  
```

## `req()`

Use in a reactive to require an input value before any calculation. Don't compute at all unless `longSlider` is set.


```{mermaid}
flowchart LR
    D["coords()"] --> E
    B["latSlider"] --> D
    C["req(longSlider)"] --> D
    E[leafletPlot]
```


## `eventReactive()` is for specific events

```{r}
actionButton("actButton", "Push to Update")
sliderInput("latSlider", "Choose a Latitude", min = 30, max=40, value=35)
sliderInput("longSlider", "Choose a Longitude", min= 30, max=40, value=35)
```

Trigger reactive computation only when `actButton` is pressed (this is the event). Don't change when `latSlider` or `longSlider` are changed. Returns a reactive when called

```{mermaid}
flowchart LR
  A[actButton] --> D
  D["eventReactive(input$actButton, )"] --> E
  B[latSlider] -- X --> D
  C[longSlider] -- X --> D
  E[leafletPlot]
```


## `observeEvent()` is for side effects

Use `observeEvent()` when you don't need to return a reactive; usually something like saving a file, or printing a file, or triggering a function.


```{r}

```

### Useful with `observeEvent()`: `bslib::input_task_button()`

"Locks up" when pressed. Won't let you press again until your task is done. 


```{r}
#| eval: false

ui <- page_sidebar(
  sidebar = sidebar(
    open = "always",
    input_task_button("resample", "Resample"),
  ),
  verbatimTextOutput("summary")
)

server <- function(input, output, session) {
  sample <- eventReactive(input$resample, ignoreNULL=FALSE, {
    Sys.sleep(2)  # Make this artificially slow
    rnorm(100)
  })

  output$summary <- renderPrint({
    summary(sample())
  })
}

shinyApp(ui, server)
```


## Be careful with `observe()`

### `observe() |> bind_event()`
